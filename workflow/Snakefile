configfile: 'config/config.yaml'

from pathlib import Path

def list_scans(root_folder, prefix):
    mapping = {}

    for path in Path(root_folder).iterdir():
        if not path.is_dir() and not path.suffix == ".zip":
            continue

        infos = [s.lower() for s in path.stem.replace(prefix, "").split("_")]
        if len(infos) == 2:
            infos += ["a"]

        cohort, subject, session = infos

        if path.is_dir():
            mapping[(cohort + subject, session)] = path
        else:
            mapping[(cohort + subject, session)] = path.with_suffix("")

    return mapping

MAPPING = list_scans(config["datadir"], config["ethics_prefix"])
SUBJECTS, SESSIONS = zip(*MAPPING)

def get_qc_status_files(wildcards):
    qc_files = []

    for subject, session in zip(SUBJECTS, SESSIONS):
        # create a dependency on heudiconv rule output
        checkpoints.heudiconv.get(
            session=session, subject=subject, resultsdir=config["resultsdir"]
        )

        # find all entities (e.g. runs) for a subject/session pair
        bids_pattern = (
            f"{config['resultsdir']}/bids/sub-{subject}/ses-{session}"
            f"/anat/sub-{subject}_ses-{session}_{{entity}}_T1w.nii.gz"
        )
        entities, = glob_wildcards(bids_pattern)

        # generate the list of QC status files
        qc_file_pattern = (
            "{resultsdir}/bids/derivatives/qc_status/"
            "sub-{subject}_ses-{session}_{entity}_qc.yaml"
        )
        qc_file, = expand(
            qc_file_pattern,
            entity=entities,
            session=session,
            subject=subject,
            resultsdir=config["resultsdir"]
        )

        qc_files.append(qc_file)

    return qc_files

rule all:
    localrule: True
    input:
        expand(
            expand(
                "{{resultsdir}}/bids/sub-{subject}/ses-{session}",
                zip,
                subject=SUBJECTS,
                session=SESSIONS,
            ),
            resultsdir=config["resultsdir"],
        ),
        get_qc_status_files

rule unzip:
    input:
        expand("{datadir}/{{folder}}.zip", datadir=config['datadir'])
    output:
        directory(expand("{datadir}/{{folder}}", datadir=config['datadir']))
    shell:
        "unzip -q -d {output} {input}"

rule tidy_dicoms:
    input:
        lambda wildards: MAPPING[(wildards.subject, wildards.session)]
    output:
        temp(directory("{resultsdir}/tidy/sub_{subject}/ses_{session}"))
    run:
        output_folder = Path(output[0])
        for dicom_file in Path(input[0]).rglob("*.dcm"):
            target_folder = output_folder / dicom_file.parent.name
            target_folder.mkdir(parents=True, exist_ok=True)
            (target_folder / dicom_file.name).symlink_to(dicom_file)

checkpoint heudiconv:
    input:
        "{resultsdir}/tidy/sub_{subject}/ses_{session}"
    output:
        directory("{resultsdir}/bids/sub-{subject}/ses-{session}"),
        directory("{resultsdir}/bids/.heudiconv/{subject}/ses-{session}")
    container:
        "docker://ghcr.io/mataimri/heudiconv:jpeg2000_ci"
    threads: config["heudiconv"]["threads"]
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["heudiconv"]["mem_mb"],
        runtime=config["heudiconv"]["time_min"]
    shell:
        "heudiconv "
        "--dicom_dir_template '{wildcards.resultsdir}/tidy/sub_{{subject}}/ses_{{session}}/*/*' "
        "--outdir {wildcards.resultsdir}/bids "
        "--heuristic {config[heudiconv][heuristic]} "
        "--subjects {wildcards.subject} "
        "--ses {wildcards.session} "
        "--converter dcm2niix "
        "--bids notop "
        "--overwrite"

rule bids_template:
    input:
        expand(
            "{{resultsdir}}/bids/sub-{subject}/ses-{session}",
            zip,
            subject=SUBJECTS,
            session=SESSIONS,
        )
    output:
        "{resultsdir}/bids/dataset_description.json"
    container:
        "docker://ghcr.io/mataimri/heudiconv:jpeg2000_ci"
    shell:
        "heudiconv "
        "--files {wildcards.resultsdir}/bids "
        "--heuristic {config[heudiconv][heuristic]} "
        "--command populate-templates"

rule mriqc_workdir:
    localrule: True
    output:
        temp(directory("{resultsdir}/mriqc_tmp"))
    shell:
        "mkdir -p {output}"

# TODO avoid shared file "dataset_description.json" (use shadow rule?)
# TODO parallelise each run/task output?
# TODO allow additional parameters
rule mriqc:
    input:
        "{resultsdir}/bids/dataset_description.json",
        "{resultsdir}/bids/sub-{subject}/ses-{session}",
        workdir="{resultsdir}/mriqc_tmp",
    output:
        directory("{resultsdir}/bids/derivatives/mriqc/sub-{subject}/ses-{session}")
    container:
        "docker://nipreps/mriqc:23.0.1"
    resources:
        cpus=lambda wildcards, threads: threads,
        mem_mb=config["mriqc"]["mem_mb"],
        runtime=config["mriqc"]["time_min"]
    params:
        mem_gb=int(config["mriqc"]["mem_mb"] / 1000)
    threads: config["mriqc"]["threads"]
    shell:
        "mriqc {wildcards.resultsdir}/bids {wildcards.resultsdir}/bids/derivatives/mriqc "
        "participant "
        "--participant-label {wildcards.subject} "
        "--session-id {wildcards.session} "
        "--mem-gb {params.mem_gb} "
        "--nprocs {threads} "
        "--no-sub "
        "-w {input.workdir}"

rule qc_status:
    input:
        "{resultsdir}/bids/derivatives/mriqc/sub-{subject}/ses-{session}"
    output:
        "{resultsdir}/bids/derivatives/qc_status/sub-{subject}_ses-{session}_{entity}_qc.yaml"
    shell:
        "touch {output}"
